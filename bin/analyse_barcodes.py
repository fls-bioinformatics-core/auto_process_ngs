#!/usr/bin/env python
#
#     analyse_barcodes.py: analyse index sequences from Illumina FASTQs
#     Copyright (C) University of Manchester 2016 Peter Briggs
#
"""
analyse_barcodes.py

Counts the index sequences (i.e. barcodes) for all reads in one or more
Fastq files, and reports the most numerous. Will also check against the
sequences supplied in a SampleSheet file and highlight those that are
missing or which have very low counts.

"""

import optparse
import sys
import os
import tempfile
from bcftbx.IlluminaData import IlluminaData
from bcftbx.IlluminaData import IlluminaDataError
from bcftbx.IlluminaData import SampleSheet
from bcftbx.IlluminaData import samplesheet_index_sequence
from bcftbx.FASTQFile import FastqIterator
from bcftbx.utils import parse_lanes
from auto_process_ngs.barcodes.analysis import BarcodeCounter
from auto_process_ngs.barcodes.analysis import Reporter
from auto_process_ngs.barcodes.analysis import report_barcodes
from auto_process_ngs.bcl2fastq_utils import make_custom_sample_sheet
from auto_process_ngs.bcl2fastq_utils import check_barcode_collisions
from auto_process_ngs.tenx_genomics_utils import has_chromium_sc_indices

__version__ = "0.1.0"

#######################################################################
# Functions
#######################################################################

def count_barcodes_bcl2fastq(dirn):
    """
    Count the barcodes from bcl2fastq output

    """
    try:
        unaligned = os.path.basename(dirn.rstrip(os.sep))
        dirn = os.path.dirname(os.path.abspath(dirn.rstrip(os.sep)))
        illumina_data = IlluminaData(dirn,unaligned_dir=unaligned)
    except IlluminaDataError,ex:
        print "%s: not an Illumina output directory?" % dirn
        raise ex
    fqs = []
    for p in illumina_data.projects:
        for s in p.samples:
            for fq in s.fastq_subset(read_number=1,full_path=True):
                fqs.append(fq)
    if illumina_data.undetermined:
        for s in illumina_data.undetermined.samples:
            for fq in s.fastq_subset(read_number=1,full_path=True):
                fqs.append(fq)
    return count_barcodes(fqs)

def count_barcodes(fastqs):
    """
    Count the barcodes from multiple fastqs

    """
    print "Reading in %s fastq%s" % (len(fastqs),
                                     ('' if len(fastqs) == 1
                                      else 's'))
    counts = BarcodeCounter()
    for fq in fastqs:
        print "%s" % os.path.basename(fq)
        for r in FastqIterator(fq):
            seq = r.seqid.index_sequence
            lane = int(r.seqid.flowcell_lane)
            counts.count_barcode(seq,lane)
    return counts

# Main program
if __name__ == '__main__':
    p = optparse.OptionParser(usage=
                              "\n\t%prog FASTQ [FASTQ...]\n"
                              "\t%prog DIR\n"
                              "\t%prog -c COUNTS_FILE [COUNTS_FILE...]",
                              version="%%prog %s" % __version__,
                              description="Collate and report counts and "
                              "statistics for Fastq index sequences (aka "
                              "barcodes). If multiple Fastq files are "
                              "supplied then sequences will be pooled before "
                              "being analysed. If a single directory is "
                              "supplied then this will be assumed to "
                              "be an output directory from CASAVA or "
                              "bclToFastq and files will be processed on a "
                              "per-lane basis. If the -c option is "
                              "supplied then the input must be one or more "
                              "file of barcode counts generated previously "
                              "using the -o option.")
    p.add_option('-c','--counts',
                 action='store_true',dest='use_counts',default=False,
                 help="input is one or more counts files generated by "
                 "previous runs")
    p.add_option('-o','--output',
                 action='store',dest='counts_file_out',default=None,
                 help="output all counts to tab-delimited file "
                 "COUNTS_FILE. This can be used again in another "
                 "run by specifying the '-c' option.")
    p.add_option('-l','--lanes',action='store',dest='lanes',default=None,
                 help="restrict analysis to the specified lane numbers "
                 "(default is to process all lanes). Multiple lanes "
                 "can be specified using ranges (e.g. '2-3'), comma-"
                 "separated list ('5,7') or a mixture ('2-3,5,7')")
    p.add_option('-m','--mismatches',action='store',dest='mismatches',
                 default=None,type='int',
                 help="maximum number of mismatches to use when "
                 "grouping similar barcodes (will be determined "
                 "automatically if samplesheet is supplied, otherwise "
                 "defaults to 0)")
    p.add_option('--cutoff',action='store',dest='cutoff',
                 default=0.001,type='float',
                 help="exclude barcodes with a smaller fraction of "
                 "associated reads than CUTOFF, e.g. '0.01' excludes "
                 "barcodes with < 0.01% of reads (default is 0.1%)")
    p.add_option('-s','--sample-sheet',
                 action='store',dest='sample_sheet',default=None,
                 help="report best matches against barcodes in "
                 "SAMPLE_SHEET")
    p.add_option('-r','--report',
                 action='store',dest='report_file',default=None,
                 help="write report to REPORT_FILE (otherwise write to "
                 "stdout)")
    p.add_option('-x','--xls',
                 action='store',dest='xls_file',default=None,
                 help="write XLS version of report to XLS_FILE")
    p.add_option('-f','--html',
                 action='store',dest='html_file',default=None,
                 help="write HTML version of report to HTML_FILE")
    p.add_option('-t','--title',
                 action='store',dest='title',default=None,
                 help="title for HTML report (default: 'Barcodes "
                 "Report')")
    p.add_option('-n','--no-report',
                 action='store_true',dest='no_report',default=None,
                 help="suppress reporting (overrides --report)")
    # Report name and version
    p.print_version()
    # Process command line
    opts,args = p.parse_args()
    # Anything to do?
    if len(args) == 0:
        if opts.use_counts:
            p.error("Needs at least one barcode counts file")
        else:
            p.error("Needs at least one FASTQ file, or a bcl2fastq directory")
    # Set default return value
    retval = 0
    # Determine mode
    if opts.use_counts:
        # Read counts from counts file(s)
        counts = BarcodeCounter(*args)
    elif len(args) == 1 and os.path.isdir(args[0]):
        # Generate counts from bcl2fastq output
        counts = count_barcodes_bcl2fastq(args[0])
    else:
        # Generate counts from fastq files
        counts = count_barcodes(args)
    # Determine subset of lanes to examine
    if opts.lanes is not None:
        lanes = parse_lanes(opts.lanes)
    else:
        lanes = counts.lanes
    # Deal with cutoff
    if opts.cutoff == 0.0:
        cutoff = None
    else:
        cutoff = opts.cutoff
    # Deal with samplesheet
    if opts.sample_sheet:
        sample_sheet = os.path.abspath(opts.sample_sheet)
    else:
        sample_sheet = None
    # Report the counts
    if not opts.no_report:
        reporter = Reporter()
        for lane in lanes:
            # Report for each lane
            if lane not in counts.lanes:
                logging.error("Requested analysis for lane %d but "
                              "only have counts for lanes %s" %
                              (lane,
                               ','.join([str(l) for l in counts.lanes])))
                retval = 1
                continue
            mismatches = opts.mismatches
            # Deal with sample sheet if supplied
            if sample_sheet:
                with tempfile.NamedTemporaryFile() as fp:
                    # Make a temporary sample sheet with just the
                    # requested lane
                    s = SampleSheet(sample_sheet)
                    if s.has_lanes:
                        use_lanes = (lane,)
                        s = make_custom_sample_sheet(sample_sheet,
                                                     fp.name,
                                                     lanes=(lane,))
                    else:
                        s = make_custom_sample_sheet(sample_sheet,
                                                     fp.name)
                    if has_chromium_sc_indices(fp.name):
                        logging.warning("Lane %s has 10xGenomics Chromium "
                                        "indices in sample sheet; not "
                                        "matching against samplesheet for "
                                        "this lane" % lane)
                        continue
                    # If mismatches not set then determine from
                    # the barcode lengths in the temporary
                    # samplesheet
                    if mismatches is None:
                        barcode_length = None
                        for line in s:
                            length = len(samplesheet_index_sequence(line))
                            if barcode_length is None:
                                barcode_length = length
                            elif length != barcode_length:
                                logging.error("Lane %s has a mixture of "
                                              "barcode lengths" % lane)
                                barcode_length = min(barcode_length,length)
                        if barcode_length >= 6:
                            mismatches = 1
                        else:
                            mismatches = 0
                        # Check for collisions
                        while mismatches and check_barcode_collisions(
                                fp.name,mismatches):
                            mismatches = mismatches - 1
            # Check mismatches
            if mismatches is None:
                # Set according to barcode lengths found in counts
                barcode_length = min(counts.barcode_lengths(lane=lane))
                if barcode_length >= 6:
                    mismatches = 1
                else:
                    mismatches = 0
            # Report the analysis
            report_barcodes(counts,
                            lane=lane,
                            cutoff=cutoff,
                            sample_sheet=sample_sheet,
                            mismatches=mismatches,
                            reporter=reporter)
        if opts.report_file is not None:
            print "Writing report to %s" % opts.report_file
            reporter.write(filen=opts.report_file,title=opts.title)
        else:
            reporter.write(title=opts.title)
        if opts.xls_file is not None:
            print "Writing XLS to %s" % opts.xls_file
            reporter.write_xls(opts.xls_file,title=opts.title)
        if opts.html_file is not None:
            print "Writing HTML to %s" % opts.html_file
            reporter.write_html(opts.html_file,title=opts.title)
    # Output counts if requested
    if opts.counts_file_out is not None:
        counts.write(opts.counts_file_out)
    # Finish
    sys.exit(retval)
