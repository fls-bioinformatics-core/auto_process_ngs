#!/usr/bin/env python
#
#     analyse_barcodes.py: analyse index sequences from Illumina FASTQs
#     Copyright (C) University of Manchester 2016 Peter Briggs
#
"""
analyse_barcodes.py

Counts the index sequences (i.e. barcodes) for all reads in one or more
Fastq files, and reports the most numerous. Will also check against the
sequences supplied in a SampleSheet file and highlight those that are
missing or which have very low counts.

"""

import optparse
import sys
import os
from bcftbx.IlluminaData import IlluminaData
from bcftbx.IlluminaData import IlluminaDataError
from bcftbx.FASTQFile import FastqIterator
from bcftbx.utils import parse_lanes
from auto_process_ngs.barcodes.analysis import BarcodeCounter
from auto_process_ngs.barcodes.analysis import Reporter
from auto_process_ngs.barcodes.analysis import report_barcodes

__version__ = "0.0.1"

#######################################################################
# Functions
#######################################################################

def count_barcodes_bcl2fastq(dirn):
    """
    Count the barcodes from bcl2fastq output

    """
    try:
        unaligned = os.path.basename(dirn.rstrip(os.sep))
        dirn = os.path.dirname(os.path.abspath(dirn.rstrip(os.sep)))
        illumina_data = IlluminaData(dirn,unaligned_dir=unaligned)
    except IlluminaDataError,ex:
        print "%s: not an Illumina output directory?" % dirn
        raise ex
    fqs = []
    for p in illumina_data.projects:
        for s in p.samples:
            for fq in s.fastq_subset(read_number=1,full_path=True):
                fqs.append(fq)
    if illumina_data.undetermined:
        for s in illumina_data.undetermined.samples:
            for fq in s.fastq_subset(read_number=1,full_path=True):
                fqs.append(fq)
    return count_barcodes(fqs)

def count_barcodes(fastqs):
    """
    Count the barcodes from multiple fastqs

    """
    print "Reading in %s fastq%s" % (len(fastqs),
                                     ('' if len(fastqs) == 1
                                      else 's'))
    counts = BarcodeCounter()
    for fq in fastqs:
        print "%s" % os.path.basename(fq)
        for r in FastqIterator(fq):
            seq = r.seqid.index_sequence
            lane = int(r.seqid.flowcell_lane)
            counts.count_barcode(seq,lane)
    return counts

# Main program
if __name__ == '__main__':
    p = optparse.OptionParser(usage=
                              "\n\t%prog FASTQ [FASTQ...]\n"
                              "\t%prog DIR\n"
                              "\t%prog -c COUNTS_FILE [COUNTS_FILE...]",
                              version="%%prog %s" % __version__,
                              description="Collate and report counts and "
                              "statistics for Fastq index sequences (aka "
                              "barcodes). If multiple Fastq files are "
                              "supplied then sequences will be pooled before "
                              "being analysed. If a single directory is "
                              "supplied then this will be assumed to "
                              "be an output directory from CASAVA or "
                              "bclToFastq and files will be processed on a "
                              "per-lane basis. If the -c option is "
                              "supplied then the input must be one or more "
                              "file of barcode counts generated previously "
                              "using the -o option.")
    p.add_option('-c','--counts',
                 action='store_true',dest='use_counts',default=False,
                 help="input is one or more counts files generated by "
                 "previous runs")
    p.add_option('-o','--output',
                 action='store',dest='counts_file_out',default=None,
                 help="output all counts to tab-delimited file "
                 "COUNTS_FILE. This can be used again in another "
                 "run by specifying the '-c' option.")
    p.add_option('-l','--lanes',action='store',dest='lanes',default=None,
                 help="restrict analysis to the specified lane numbers "
                 "(default is to process all lanes). Multiple lanes "
                 "can be specified using ranges (e.g. '2-3'), comma-"
                 "separated list ('5,7') or a mixture ('2-3,5,7')")
    p.add_option('-m','--mismatches',action='store',dest='mismatches',
                 default=0,type='int',
                 help="maximum number of mismatches to use when "
                 "grouping similar barcodes (default is 0)")
    p.add_option('--cutoff',action='store',dest='cutoff',
                 default=0.001,type='float',
                 help="exclude barcodes with a smaller fraction of "
                 "associated reads than CUTOFF, e.g. '0.01' excludes "
                 "barcodes with < 0.01% of reads (default is 0.1%)")
    p.add_option('-s','--sample-sheet',
                 action='store',dest='sample_sheet',default=None,
                 help="report best matches against barcodes in "
                 "SAMPLE_SHEET")
    p.add_option('-r','--report',
                 action='store',dest='report_file',default=None,
                 help="write report to REPORT_FILE (otherwise write to "
                 "stdout)")
    p.add_option('-x','--xls',
                 action='store',dest='xls_file',default=None,
                 help="write XLS version of report to XLS_FILE")
    p.add_option('-f','--html',
                 action='store',dest='html_file',default=None,
                 help="write HTML version of report to HTML_FILE")
    p.add_option('-n','--no-report',
                 action='store_true',dest='no_report',default=None,
                 help="suppress reporting (overrides --report)")
    # Report name and version
    p.print_version()
    # Process command line
    opts,args = p.parse_args()
    # Anything to do?
    if len(args) == 0:
        if opts.use_counts:
            p.error("Needs at least one barcode counts file")
        else:
            p.error("Needs at least one FASTQ file, or a bcl2fastq directory")
    # Determine subset of lanes to examine
    if opts.lanes is not None:
        lanes = parse_lanes(opts.lanes)
    else:
        lanes = None
    # Determine mode
    if opts.use_counts:
        # Read counts from counts file(s)
        counts = BarcodeCounter(*args)
    elif len(args) == 1 and os.path.isdir(args[0]):
        # Generate counts from bcl2fastq output
        counts = count_barcodes_bcl2fastq(args[0])
    else:
        # Generate counts from fastq files
        counts = count_barcodes(args)
    # Deal with cutoff
    if opts.cutoff == 0.0:
        cutoff = None
    else:
        cutoff = opts.cutoff
    # Report the counts
    if not opts.no_report:
        reporter = Reporter()
        if lanes is None:
            report_barcodes(counts,
                            cutoff=cutoff,
                            sample_sheet=opts.sample_sheet,
                            mismatches=opts.mismatches,
                            reporter=reporter)
        else:
            for lane in lanes:
                if lane not in counts.lanes:
                    logging.error("Requested analysis for lane %d but "
                                  "only have counts for lanes %s" %
                                  (lane,
                                   ','.join([str(l) for l in counts.lanes])))
                    sys.exit(1)
                report_barcodes(counts,
                                lane=lane,
                                cutoff=cutoff,
                                sample_sheet=opts.sample_sheet,
                                mismatches=opts.mismatches,
                                reporter=reporter)
        if opts.report_file is not None:
            print "Writing report to %s" % opts.report_file
            reporter.write(filen=opts.report_file)
        else:
            reporter.write()
        if opts.xls_file is not None:
            print "Writing XLS to %s" % opts.xls_file
            reporter.write_xls(opts.xls_file)
        if opts.html_file is not None:
            print "Writing HTML to %s" % opts.html_file
            reporter.write_html(opts.html_file)
    # Output counts if requested
    if opts.counts_file_out is not None:
        counts.write(opts.counts_file_out)
