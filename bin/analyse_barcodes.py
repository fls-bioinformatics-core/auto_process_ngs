#!/usr/bin/env python
#
#     analyse_barcodes.py: analyse index sequences from Illumina FASTQs
#     Copyright (C) University of Manchester 2016 Peter Briggs
#
"""
analyse_barcodes.py

Counts the index sequences (i.e. barcodes) for all reads in one or more
Fastq files, and reports the most numerous. Will also check against the
sequences supplied in a SampleSheet file and highlight those that are
missing or which have very low counts.

"""

import optparse
import sys
import os
from bcftbx.IlluminaData import IlluminaData
from bcftbx.IlluminaData import IlluminaDataError
from bcftbx.FASTQFile import FastqIterator
from auto_process_ngs.barcode_analysis import BarcodeCounter
from auto_process_ngs.barcode_analysis import Reporter
from auto_process_ngs.barcode_analysis import report_barcodes

__version__ = "0.0.1"

#######################################################################
# Functions
#######################################################################

def count_barcodes_bcl2fastq(dirn):
    """
    Count the barcodes from bcl2fastq output

    """
    try:
        unaligned = os.path.basename(dirn.rstrip(os.sep))
        dirn = os.path.dirname(os.path.abspath(dirn.rstrip(os.sep)))
        illumina_data = IlluminaData(dirn,unaligned_dir=unaligned)
    except IlluminaDataError,ex:
        print "%s: not an Illumina output directory?" % dirn
        raise ex
    fqs = []
    for p in illumina_data.projects:
        for s in p.samples:
            for fq in s.fastq_subset(read_number=1,full_path=True):
                fqs.append(fq)
    if illumina_data.undetermined:
        for s in illumina_data.undetermined.samples:
            for fq in s.fastq_subset(read_number=1,full_path=True):
                fqs.append(fq)
    return count_barcodes(fqs)

def count_barcodes(fastqs):
    """
    Count the barcodes from multiple fastqs

    """
    print "Reading in %s fastq%s" % (len(fastqs),
                                     ('' if len(fastqs) == 1
                                      else 's'))
    counts = BarcodeCounter()
    for fq in fastqs:
        print "%s" % os.path.basename(fq)
        for r in FastqIterator(fq):
            seq = r.seqid.index_sequence
            lane = int(r.seqid.flowcell_lane)
            counts.count_barcode(seq,lane)
    return counts

def parse_lanes_expression(lanes):
    """
    Parse a string and return list of lane numbers

    Process a string specifying one or more lane numbers
    expressed as a single digit and returns a sorted
    list of unique lane numbers.

    For example:

    >>> parse_lanes_expression('1')
    [1]

    or as a list of digits:

    >>> parse_lanes_expression('1,3')
    [1, 3]

    or as a range of digits:

    >>> parse_lanes_expression('5-7')
    [5, 6, 7]

    or as a mixture of both:

    >>> parse_lanes_expression('1,3,5-7')
    [1, 3, 5, 6, 7]
    
    """
    if lanes is None:
        return None
    lane_numbers = []
    for l in lanes.split(','):
        l1 = l.split('-')
        if len(l1) == 1:
            lane_numbers.append(int(l))
        else:
            lane_numbers.extend(xrange(int(l1[0]),int(l1[1])+1))
    lane_numbers = sorted(set(lane_numbers))
    return lane_numbers

# Main program
if __name__ == '__main__':
    p = optparse.OptionParser(usage=
                              "\n\t%prog FASTQ [FASTQ...]\n"
                              "\t%prog DIR\n"
                              "\t%prog -c COUNTS_FILE [COUNTS_FILE...]",
                              version="%%prog %s" % __version__,
                              description="Collate and report counts and "
                              "statistics for Fastq index sequences (aka "
                              "barcodes). If multiple Fastq files are "
                              "supplied then sequences will be pooled before "
                              "being analysed. If a single directory is "
                              "supplied then this will be assumed to "
                              "be an output directory from CASAVA or "
                              "bclToFastq and files will be processed on a "
                              "per-lane basis. If the -c option is "
                              "supplied then the input must be one or more "
                              "file of barcode counts generated previously "
                              "using the -o option.")
    p.add_option('-c','--counts',
                 action='store_true',dest='use_counts',default=False,
                 help="input is one or more counts files generated by "
                 "previous runs")
    p.add_option('-o','--output',
                 action='store',dest='counts_file_out',default=None,
                 help="output all counts to tab-delimited file "
                 "COUNTS_FILE. This can be used again in another "
                 "run by specifying the '-c' option.")
    p.add_option('-l','--lanes',action='store',dest='lanes',default=None,
                 help="restrict analysis to the specified lane numbers "
                 "(default is to process all lanes). Multiple lanes "
                 "can be specified using ranges (e.g. '2-3'), comma-"
                 "separated list ('5,7') or a mixture ('2-3,5,7')")
    p.add_option('-m','--mismatches',action='store',dest='mismatches',
                 default=0,type='int',
                 help="maximum number of mismatches to use when "
                 "grouping similar barcodes (default is 0)")
    p.add_option('--cutoff',action='store',dest='cutoff',
                 default=0.001,type='float',
                 help="exclude barcodes with a smaller fraction of "
                 "associated reads than CUTOFF, e.g. '0.01' excludes "
                 "barcodes with < 0.01% of reads (default is 0.1%)")
    p.add_option('--coverage',action='store',dest='coverage',
                 default=None,type='float',
                 help="include most numerous barcodes to cover only "
                 "the fraction of reads specified by COVERAGE, e.g. "
                 "'0.9' limits barcodes to those associated with 90% "
                 " of total reads (default is to include all barcodes)")
    p.add_option('-s','--sample-sheet',
                 action='store',dest='sample_sheet',default=None,
                 help="report best matches against barcodes in "
                 "SAMPLE_SHEET")
    p.add_option('-r','--report',
                 action='store',dest='report_file',default=None,
                 help="write report to REPORT_FILE (otherwise write to "
                 "stdout)")
    p.add_option('-x','--xls',
                 action='store',dest='xls_file',default=None,
                 help="write XLS version of report to XLS_FILE")
    p.add_option('-n','--no-report',
                 action='store_true',dest='no_report',default=None,
                 help="suppress reporting (overrides --report)")
    # Report name and version
    p.print_version()
    # Process command line
    opts,args = p.parse_args()
    # Anything to do?
    if len(args) == 0:
        if opts.use_counts:
            p.error("Needs at least one barcode counts file")
        else:
            p.error("Needs at least one FASTQ file, or a bcl2fastq directory")
    # Determine subset of lanes to examine
    lanes = parse_lanes_expression(opts.lanes)
    # Determine mode
    if opts.use_counts:
        # Read counts from counts file(s)
        counts = BarcodeCounter(*args)
    elif len(args) == 1 and os.path.isdir(args[0]):
        # Generate counts from bcl2fastq output
        counts = count_barcodes_bcl2fastq(args[0])
    else:
        # Generate counts from fastq files
        counts = count_barcodes(args)
    # Deal with cutoff
    if opts.cutoff == 0.0:
        cutoff = None
    else:
        cutoff = opts.cutoff
    # Report the counts
    if not opts.no_report:
        reporter = Reporter()
        if lanes is None:
            report_barcodes(counts,
                            cutoff=cutoff,
                            sample_sheet=opts.sample_sheet,
                            mismatches=opts.mismatches,
                            reporter=reporter)
        else:
            for lane in lanes:
                if lane not in counts.lanes:
                    logging.error("Requested analysis for lane %d but "
                                  "only have counts for lanes %s" %
                                  (lane,
                                   ','.join([str(l) for l in counts.lanes])))
                    sys.exit(1)
                report_barcodes(counts,
                                lane=lane,
                                cutoff=cutoff,
                                sample_sheet=opts.sample_sheet,
                                mismatches=opts.mismatches,
                                reporter=reporter)
        if opts.report_file is not None:
            print "Writing report to %s" % opts.report_file
            reporter.write(filen=opts.report_file)
        else:
            reporter.write()
        if opts.xls_file is not None:
            print "Writing XLS to %s" % opts.xls_file
            reporter.write_xls(opts.xls_file)
    # Output counts if requested
    if opts.counts_file_out is not None:
        counts.write(opts.counts_file_out)
